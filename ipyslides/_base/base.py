"Inherit LiveSlides class from here. It adds useful attributes and methods."
import json, re, os
from contextlib import suppress
from .widgets import Widgets
from .print_pdf import PdfPrint
from .navigation import Navigation
from .settings import LayoutSettings
from .notes import Notes

class BaseLiveSlides:
    def __init__(self):
        "Both instnaces should be inside `LiveSlide` class."
        self.__widgets = Widgets()
        self.__print = PdfPrint(self.__widgets)
        self.__navigation = Navigation(self.__widgets) # Not accessed later, just for actions
        self.__settings = LayoutSettings(self.__widgets)
        self.notes = Notes(self, self.__widgets) # Needs main class for access to notes
        
        self.__toasts = {} #Store notifications
        self.toast_html = self.widgets.htmls.toast
        
        self.widgets.checks.toast.observe(self.__toggle_notify,names=['value'])
    
    @property
    def widgets(self):
        return self.__widgets
    
    @property
    def print(self):
        return self.__print
    
    @property
    def settings(self):
        return self.__settings
    
    def notify(self,content,title='IPySlides Notification',timeout=5):
        "Send inside notifications for user to know whats happened on some button click. Set `title = None` if need only content. Remain invisible in screenshot."
        return self.widgets._push_toast(content,title=title,timeout=timeout)
    
    def __toggle_notify(self,change):
        "Blocks notifications."
        if self.toast_check.value:
            self.toast_html.layout.visibility = 'hidden' 
        else:
            self.toast_html.layout.visibility = 'visible'
    
    def notify_at(self, slide, title='IPySlides Notification', timeout=5):
        """Decorartor to push notification at given slide. It should return as string. `slide` here is what you see on slides's footer like 3.1, not just int.
        The content is dynamically generated by underlying function, so you can set timer as well. Remains invisible in screenshot through app itself.
        
        @notify_at(slide=1)
        def push_to(slide): #you can refer slide number in noteification function. 
            ..."""
        def _notify(func): 
            self.__toasts[f'{slide}'] = dict(func = func,arg = slide,kwargs = dict(title=title, timeout=timeout))
        return _notify
    
    def clear_notifications(self):
        "Remove all redundent notifications that show up."
        self.__toasts = {} # Free up
    
    @property
    def notifications(self):
        "See all stored notifications."
        return self.__toasts
    
    def display_toast(self):
        # self.iterable is picked from LiveSlide class after instantiation
        with suppress(BaseException): # Try and bypass any error
            slide_id = str(self.iterable[self.widgets.sliders.progress.value - 1]['n'])
            toast = self.__toasts[slide_id]
            self.notify(content=toast['func'](toast['arg']),**toast['kwargs'])
        

    def load_ipynb(self, filename, footer_text = 'Author Name'):
        """If you want to create slides in clean and linear execution way, use this method. It overrides `load_md`.
            
            - First cell of notebook should be imports and it will be executed.
                
                import ipyslides as isd
                slides = isd.LiveSlides() # This line will not re-run to avoid conflicts
                
            - Next cell will be used to create title page
                This should not have %%title or `with title`
            - Other cells will be slides
                Do not use `with slides.slide` context manager if you use this function
                use other methods freely e.g.
                
                %%slide
                slides.cite...
                slides.notes.insert...
                slide.image...
            
            - Last cell should call `slides.load_ipynb(filename)`.
                
            - A cell with tag `#hide` will not be executed.
        
        > Make sure notebook is saved before using this function. 
        """
        if not os.path.isfile(filename):
            raise ValueError(f"File {filename!r} does not exist!")
        
        with open(filename, 'r') as f:
            try:
                nb = json.load(f, cls = DecodeCleanNotebook)
            except:
                raise ValueError(f'Notebook {filename!r}cannot be parsed')
        
        # clean cells
        for i, cell in enumerate(nb['cells']):
            if cell['source'] and '#hide' in cell['source'][0]: # skip cells first if #hide even in markdown cell
                nb['cells'][i]['source'] = []
            for j, line in enumerate(cell['source']):
                if cell['cell_type'] == 'code':
                    for word in ['%%slide','load_ipynb','LiveSlides','load_md']: # do not include %%title as it is special case
                        if word in line or line.lstrip().startswith('#'): # skip lines
                            nb['cells'][i]['source'][j] = ''   #This keep slides created with %%slide available
            
            nb['cells'][i]['source'] = ''.join(ln for ln in cell['source'] if ln.strip()) #\n reamins there, so strip it
        
        cells = [cell for cell in nb['cells'] if cell['source']]
        # check if previous slides excpet with %%slide as that line is processed
        for cell in cells:
            for check in ['^%%title','with*.title','@*.frames','with*.slide']: # Nod idea why . matches . and nothing too
                if re.search(check, cell['source']):
                    return self.shell.run_cell_magic('markdown','',f'<span style="color:red">Cannot recreate a previously created slide</span>\n```python\n{cell["source"]}\n```')

        if len(cells) < 2:
            raise ValueError('Notebook should have at least 2 cells, first cell is just for imports and cell where `load_ipynb` is run is not included.')

        if cells[0]['cell_type'] == 'code':
            self.shell.run_cell(cells[0]['source']) # run for any imports
            
        self.convert2slides(True) # call before adding slides
        self.clear() # Clean all other slides if any
        self.settings.set_footer(footer_text)
        
        with self.title():
            if cells[1]['cell_type'] == 'code':
                self.shell.run_cell(cells[1]['source'])
            else:
                self.write(cells[1]['source']) # Usually Markdown cell for title

        for i, cell in enumerate(cells[2:],start = 1):
            with self.slide(i):
                source = cell['source']
                if cell['cell_type'] == 'code':
                    self.shell.run_cell(source)
                else:
                    self.write(source) # Markdown
        
        return self
    
    def load_md(self, filename, footer_text = 'Author Name'):
        """You can create slides from a markdown file as well. It overrides `load_ipynb`.
        Slides separator should be --- (three dashes) in start of line.
        _________ Markdown File Content __________
        # Talk Title
        ---
        # Slide 1 
        ---
        # Slide 2
        ___________________________________________
        This will create two slides along with title page.
        
        > Note: With this method you can add more slides besides created ones.
        """
        if not os.path.isfile(filename):
            raise ValueError(f"File {filename!r} does not exist!")
        
        self.convert2slides(True)
        self.clear()
        self.settings.set_footer(footer_text)

        chunks = _parse_md_file(filename)

        with self.title():
            self.write(chunks[0])
        for i,chunk in enumerate(chunks[1:],start=1):
            with self.slide(i):
                self.write(chunk)
        
        return self
        

class DecodeCleanNotebook(json.JSONDecoder):
    """
    - Deserilizes Jupyter-Noteebook to dictionary with taking care of `#hide` in top of cell.
    - **Usage**
        - `json.load(fp,cls = DecodeCleanNotebook)`.
    """
    def __init__(self, *args, **kwargs):
        json.JSONDecoder.__init__(self, object_hook=self.object_hook, *args, **kwargs)

    def object_hook(self, obj):
        ignored = ['metadata', 'execution_count', 'outputs']
        if 'cell_type' in obj:
            obj = {k:v for k,v in obj.items() if k not in ignored}
        return obj


def _parse_md_file(md_file):
    "Parse a Markdown file to put in slides and returns text for title and each slide."
    with open(md_file,'r') as f:
        lines = f.readlines()
        breaks = [-1] # start, will add +1 next
        for i,line in enumerate(lines):
            if line and line.strip() =='---':
                breaks.append(i)
        breaks.append(len(lines)) # Last one
        
        ranges = [range(j+1,k) for j,k in zip(breaks[:-1],breaks[1:])]
        return [''.join(lines[x.start:x.stop]) for x in ranges]
        
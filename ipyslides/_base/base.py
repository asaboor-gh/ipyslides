"Inherit LiveSlides class from here. It adds useful attributes and methods."
import json, re, os, io
from contextlib import suppress
from .widgets import Widgets
from .print_pdf import PdfPrint
from .navigation import Navigation
from .settings import LayoutSettings
from .notes import Notes

class BaseLiveSlides:
    def __init__(self):
        "Both instnaces should be inside `LiveSlide` class."
        self.__widgets = Widgets()
        self.__print = PdfPrint(self.__widgets)
        self.__navigation = Navigation(self.__widgets) # Not accessed later, just for actions
        self.__settings = LayoutSettings(self.__widgets)
        self.notes = Notes(self, self.__widgets) # Needs main class for access to notes
        
        self.__toasts = {} #Store notifications
        self.toast_html = self.widgets.htmls.toast
        
        self.widgets.checks.toast.observe(self.__toggle_notify,names=['value'])
    
    @property
    def widgets(self):
        return self.__widgets
    
    @property
    def print(self):
        return self.__print
    
    @property
    def settings(self):
        return self.__settings
    
    def notify(self,content,title='IPySlides Notification',timeout=5):
        "Send inside notifications for user to know whats happened on some button click. Set `title = None` if need only content. Remain invisible in screenshot."
        return self.widgets._push_toast(content,title=title,timeout=timeout)
    
    def __toggle_notify(self,change):
        "Blocks notifications."
        if self.toast_check.value:
            self.toast_html.layout.visibility = 'hidden' 
        else:
            self.toast_html.layout.visibility = 'visible'
    
    def notify_at(self, slide, title='IPySlides Notification', timeout=5):
        """Decorartor to push notification at given slide. It should return as string. `slide` here is what you see on slides's footer like 3.1, not just int.
        The content is dynamically generated by underlying function, so you can set timer as well. Remains invisible in screenshot through app itself.
        
        @notify_at(slide=1)
        def push_to(slide): #you can refer slide number in noteification function. 
            ..."""
        def _notify(func): 
            self.__toasts[f'{slide}'] = dict(func = func,arg = slide,kwargs = dict(title=title, timeout=timeout))
        return _notify
    
    def clear_notifications(self):
        "Remove all redundent notifications that show up."
        self.__toasts = {} # Free up
    
    @property
    def notifications(self):
        "See all stored notifications."
        return self.__toasts
    
    def display_toast(self):
        # self.iterable is picked from LiveSlide class after instantiation
        with suppress(BaseException): # Try and bypass any error
            slide_id = str(self.iterable[self.widgets.sliders.progress.value - 1]['n'])
            toast = self.__toasts[slide_id]
            self.notify(content=toast['func'](toast['arg']),**toast['kwargs'])
    
    @property
    def md_content(self):
        "Get markdown content from loaded file."
        return self._md_content
        
    
    def from_markdown(self, path, footer_text = 'Author Name'):
        """You can create slides from a markdown file or StringIO object as well. It creates slides 1,2,3... in order.
        You should add more slides by higher number than the number of slides in the file, or it will overwrite.
        Slides separator should be --- (three dashes) in start of line.
        _________ Markdown File Content __________
        # Talk Title
        ---
        # Slide 1 
        ---
        # Slide 2
        ___________________________________________
        This will create two slides along with title page.
        
        Content of each slide from imported file is stored as list in `slides.md_content`. You can append content to it like this:
        ```python
        with slides.slide(2):
            write(slides.md_content[2])
            plot_something()
            write_something()
        ```
        
        > Note: With this method you can add more slides besides created ones.
        """
        if not (isinstance(path, io.StringIO) or os.path.isfile(path)): #check path later or it will throw error
            raise ValueError(f"File {path!r} does not exist or not a io.StringIO object.")
        
        self.convert2slides(True)
        self.clear()
        self.settings.set_footer(footer_text)
        
        if isinstance(path, io.StringIO):
            chunks = _parse_md_file(path)
        else:
            with open(path, 'r') as fp:
                chunks = _parse_md_file(fp)

        with self.title():
            self.write(chunks[0])
        for i,chunk in enumerate(chunks[1:],start=1):
            with self.slide(i):
                self.write(chunk)
            
        self._md_content = chunks # Store for later use
        
        return self
        

def _parse_md_file(fp):
    "Parse a Markdown file or StringIO to put in slides and returns text for title and each slide."
    lines = fp.readlines()
    breaks = [-1] # start, will add +1 next
    for i,line in enumerate(lines):
        if line and line.strip() =='---':
            breaks.append(i)
    breaks.append(len(lines)) # Last one
    
    ranges = [range(j+1,k) for j,k in zip(breaks[:-1],breaks[1:])]
    return [''.join(lines[x.start:x.stop]) for x in ranges]
        